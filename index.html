<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Baby Jumper "Jehee" - Final Version</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: 'Arial', sans-serif; background-color: #f0f0f0; /* 배경색 추가로 캔버스 여백 확인 */ }
    canvas {
        background: #d0f4f7;
        display: block;
        /* 핵심 변경: 화면 너비에 꽉 맞추고, 높이도 최대 화면 높이까지 허용하며, 4:3 비율 유지 */
        width: 100vw; /* 뷰포트 너비에 꽉 맞춤 */
        height: auto; /* 비율에 따라 높이 자동 조절 */
        max-height: 100vh; /* 최대 높이는 뷰포트 높이로 제한 */
        aspect-ratio: 4 / 3; /* 내부 게임 해상도(800x600)의 비율을 유지 */
        margin: 0 auto; /* 중앙 정렬 */
    }
    #uiLayer {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px; /* 가로 전체를 차지 */
      display: flex;
      justify-content: space-between; /* 양쪽 끝으로 정렬 */
      align-items: center; /* 세로 중앙 정렬 */
      color: #0b3c5d;
      font-size: 24px;
      font-weight: bold;
      pointer-events: none;
      z-index: 15; /* 게임 화면 위에 오도록 */
      background-color: rgba(255, 255, 255, 0.7); /* 배경 추가 */
      padding: 10px 20px;
      border-radius: 10px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    #leftUI, #rightUI {
        display: flex;
        gap: 20px; /* 요소 간 간격 추가 */
        align-items: center;
    }

    #bubbleGauge {
        position: fixed; /* 하단 중앙으로 고정 */
        bottom: 140px; /* 모바일 컨트롤러 위에 위치 */
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 5px;
        align-items: center;
        z-index: 20; /* 다른 UI 요소보다 위에 오도록 */
        background-color: rgba(255, 255, 255, 0.7); /* 배경 추가 */
        padding: 8px 15px;
        border-radius: 20px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    .bubble-icon { width: 30px; height: 30px; opacity: 1; transition: opacity 0.2s; }
    .bubble-icon.empty { opacity: 0.2; }

    #startScreen, #winScreen, #gameOverScreen {
      position: absolute; width: 100%; height: 100%;
      background: linear-gradient(to bottom, #a8e0f7, #d9f7fc);
      display: flex; align-items: center; justify-content: center;
      flex-direction: column; z-index: 10; text-align: center;
    }
    #gameOverScreen { background: linear-gradient(to bottom, #5c5c5c, #333333); }
    #startScreen h1, #winScreen h1, #gameOverScreen h1 { font-size: 64px; color: #ff9f1c; margin-bottom: 20px; }
    #gameOverScreen h1 { color: #ff4d6d; }
    #startScreen p, #winScreen p, #gameOverScreen p { font-size: 20px; color: #3282b8; margin-bottom: 30px; }
    #gameOverScreen p { color: #cccccc; }
    #startButton, #restartButton, #restartButtonGO {
      padding: 15px 40px; font-size: 24px;
      background-color: #ff9f1c; color: white;
      border: 2px solid #e68a00; border-radius: 12px; cursor: pointer;
      box-shadow: 0 4px #e68a00;
    }
    .rankingList {
      font-size: 18px; color: #333; margin: 20px 0; text-align: left;
      background: white; padding: 15px; border-radius: 10px; width: 300px;
    }
    .rankingList h3 { margin-top: 0; text-align: center;}

    /* [모바일] 터치 컨트롤 버튼 스타일 */
    #mobileControls {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 120px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-sizing: border-box;
        padding: 20px;
        z-index: 20;
        user-select: none;
    }
    #mobileControls > div {
        display: flex;
        gap: 20px;
    }
    #leftBtn, #rightBtn, #jumpBtn, #bubbleJumpBtn {
        width: 70px;
        height: 70px;
        background-color: rgba(255, 159, 28, 0.7);
        color: white;
        font-size: 24px;
        font-weight: bold;
        display: flex;
        justify-content: center;
        align-items: center;
        border-radius: 50%;
        border: 3px solid rgba(230, 138, 0, 0.9);
        box-shadow: 0 4px rgba(230, 138, 0, 0.9);
    }
    #actionBtns {
        display: flex;
        gap: 20px;
    }

    /* 가로 모드일 때 보여줄 알림 */
    #orientation-alert {
      display: none; /* 기본적으로 숨김 */
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      font-size: 28px;
      text-align: center;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      padding: 20px;
      box-sizing: border-box;
    }

    #orientation-alert img {
        width: 80px; /* 회전 아이콘 크기 */
        height: 80px;
        margin-bottom: 20px;
    }

    /* 가로 모드일 때만 #orientation-alert를 표시 */
    @media screen and (orientation: landscape) {
      #orientation-alert {
        display: flex;
      }
      /* 가로 모드일 때 게임과 다른 UI를 숨김 */
      #gameCanvas, #uiLayer, #bubbleGauge, #mobileControls,
      #startScreen, #winScreen, #gameOverScreen {
        display: none !important;
      }
    }

    /* 초기 로딩 시에도 경고가 먼저 뜨지 않도록 body의 기본 display를 block으로 설정 */
    body { display: block; }
  </style>
</head>
<body>
  <div id="startScreen">
    <h1>Baby Jumper "Jehee"</h1>
    <p>5개의 버블로 10개의 스테이지를 정복하세요!</p>
    <p><strong>Controls:</strong> ← → to move, A to Jump, SPACE to Bubble Jump</p>
    <button id="startButton" disabled>게임 로딩중...</button>
  </div>

  <div id="winScreen" style="display: none;">
    <h1>CONGRATULATIONS!</h1>
    <p>모든 스테이지를 클리어했습니다!</p>
    <div id="rankingList" class="rankingList"></div>
    <button id="restartButton">Play Again</button>
  </div>

  <div id="gameOverScreen" style="display: none;">
    <h1>GAME OVER</h1>
    <div id="rankingListGO" class="rankingList"></div>
    <button id="restartButtonGO">Try Again</button>
  </div>

  <div id="uiLayer">
    <div id="leftUI">
      <div id="stageDisplay">Stage 1</div>
      <div id="score">Score: 0</div>
    </div>
    <div id="rightUI">
      <div id="livesDisplay">❤️ 3</div>
      <div id="timerDisplay">⏰ 20</div>
    </div>
  </div>
  <div id="bubbleGauge"></div>

  <canvas id="gameCanvas"></canvas>
  <audio id="bgm" src="./bgm.mp3" loop></audio>

  <div id="mobileControls" style="display: none;">
    <div id="leftBtn">←</div>
    <div id="rightBtn">→</div>
    <div id="actionBtns">
      <div id="bubbleJumpBtn">BUBBLE</div>
      <div id="jumpBtn">JUMP</div>
    </div>
  </div>

  <div id="orientation-alert">
    <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjgiIGhlaWdodD0iMTI4IiB2aWV3Qm94PSIwIDAgMTI4IDEyOCI+PHBhdGggZmlsbD0iI0ZGRkZGRiIgZD0iTTYzLjY1NiA2Ljk0M2MtLjI5Mi0uNTgyLS42OTgtLjU4Mi0uODM2IDAtLjExNy4zNDctLjY5NyAxLjM5LS44MzUgMS45NzVsLTE1LjIyIDI5LjkxNGMtLjI2MS41NDUtLjEzLjgyNS4zMTIuODg3aDQ1LjA3NWMuNDQyLS4wNjIuNTcyLS4zNDIuMzEyLS44ODdsLTE1LjIyLTI5LjkxNGMtLjE1LS41OTItLjU3My0xLjE3LS44NjYtMS4xNzFtLS41ODMgMTcuNzk2YzIuNzE3IDUuNDU2IDcuMjQ3IDQuMDM1IDguMDYyIDYuNTcyTDEyOCAzMC44MjZ2NjYuMzI0Yy0uMTA5IDYuNzA4LTUuNjcgMTIuMzY4LTEyLjM3MiAxMi40NzRIMTQuMzU4QzcuNjYgMTA5LjYyIDIgMTA0LjA1OSAyIDk3LjM1MVYyNS43NDJsMjcuNzcyLTcuOTMyYy44MTQtMi41MzcgNS4zNDUtMS4xMTYgOC4wNjMtNi41NzJ6bS0yNy43NzIgNjcuMTI1YzAgMi42NjYgMi4xNjUgNC44MzIgNC44MzUgNC44MzJoNzYuNDc2YzIuNjcgMCA0LjgzNC0yLjE2NiA0LjgzNC00LjgzMnYtNDkuOTI4YzAtLjI1OC0uMTU2LS40ODgtLjQxNC0uNTU3bC0zOC41NzMtMTAuODU2Yy0uNjk0LS4xOTMtMS4zOCAwLS40ODcgMi4xNThsMjEuNTYgMjEuMDQyYy40ODcuNDcyLjk2LjA0My45Ni0uNzc5di0xMi42MjljMC0uNTUyLjQ1NS0xLjAwMyAxLjAwNi0xLjAwM2gxLjIyOWMuNTUyIDAgMS4wMDMuNDUzIDEuMDAzIDEuMDAzdjIzLjYzMWMwIC40ODctLjMxMi45MTMtLjc3OS45MTMtLjI2MSAwLS41NjEtLjA5NS0uODczLS4zODZsLTI1LjA2LTI0LjA2NWMtLjI2My0uMjYzLS41NDYtLjMyNi0uODMtLjMyNnMtLjU2Mi4wNjMtLjgyNC4zMjVsLTI0LjYxIDI0LjYzNGMtLjM3NS4zNzUtLjk1NS40MzctMS4zNzEuMjA1bC0uMjE5LS4wOTVjLS40ODgtLjI4NC0uNzQ1LS44MjQtLjQ4NC0xLjM3bDIwLjU3LTIwLjE4NGMuOTYt.ODY1Ljg5Ny0xLjI0Mi42My0yLjExNWwtLjIzNy4yMTdjLS41MjItLjQzNC0xLjIyMi0uNjkxLTEuNDExLTEuMTIzbC0uNjUtLjczMi0xLjQ5OC0xLjY5OS0xNy45Mi0yMC42NTJjLS4wOTUtLjE1NS0uMTU2LS4yNjEtLjE1Ni0uNDE3di0uNTNjLS4wNjMtLjUyNC0uNDg3LS45Ni0xLjAwOS0.5LjU2MSAwLS45NzYuNDQzLS45NzYgMS4wMDN2NDkuOTI4eiIvPjwvc3ZnPg==" alt="Rotate Device">
    <p>세로 모드로 전환해 주세요.</p>
    <p>(Please switch to portrait mode)</p>
  </div>


  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    // 게임 내부 해상도는 고정
    canvas.width = 800; canvas.height = 600;

    const worldHeight = canvas.height * 2;
    const camera = {
      y: worldHeight - canvas.height,
      lerpFactor: 0.08
    };

    const babyImg = new Image(); babyImg.src = "./baby.png";
    const platformImg = new Image(); platformImg.src = "./platform.png";
    const bubbleImg = new Image(); bubbleImg.src = "./bubble.png";
    const goalImg = new Image(); goalImg.src = "./milk.png";
    const dragonImg = new Image(); dragonImg.src = "./dragon.png";
    const bgm = document.getElementById('bgm');

    let gameStarted = false, score = 0;
    let currentStage = 1;
    const totalStages = 10;
    let stageTimer = 20;
    let lastTime = 0, deltaTime = 0;

    const baby = {
      x: canvas.width / 2 - 25, y: worldHeight - 80,
      width: 50, height: 50, speed: 4,
      dx: 0, dy: 0, gravity: 0.4, jumpPower: -10,
      isJumping: false, bubblesLeft: 5, maxBubbles: 5, bubbleJumpPower: -12,
      lives: 3
    };
    const platforms = [], bubbles = [], enemies = [];
    const goal = { x: canvas.width / 2 - 20, y: 50, width: 40, height: 40 };

    const stageConfigs = [
        { stage: 1, normal: 0, fast: 0, jumper: 0 }, { stage: 2, normal: 1, fast: 0, jumper: 0 },
        { stage: 3, normal: 2, fast: 0, jumper: 0 }, { stage: 4, normal: 3, fast: 0, jumper: 0 },
        { stage: 5, normal: 4, fast: 0, jumper: 0 }, { stage: 6, normal: 3, fast: 2, jumper: 0 },
        { stage: 7, normal: 3, fast: 2, jumper: 1 }, { stage: 8, normal: 7, fast: 2, jumper: 1 },
        { stage: 9, normal: 6, fast: 4, jumper: 2 }, { stage: 10, normal: 4, fast: 8, jumper: 3 }
    ];

    const startButton = document.getElementById('startButton');
    const restartButton = document.getElementById('restartButton');
    const restartButtonGO = document.getElementById('restartButtonGO');
    const startScreen = document.getElementById('startScreen');
    const winScreen = document.getElementById('winScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const stageDisplay = document.getElementById('stageDisplay');
    const scoreText = document.getElementById('score');
    const bubbleGauge = document.getElementById('bubbleGauge');
    const livesDisplay = document.getElementById('livesDisplay');
    const timerDisplay = document.getElementById('timerDisplay');
    const rankingList = document.getElementById('rankingList');
    const rankingListGO = document.getElementById('rankingListGO');
    const orientationAlert = document.getElementById('orientation-alert');

    // 방향 확인 함수
    function checkOrientation() {
        if (window.innerWidth > window.innerHeight) {
            // 가로 모드일 때 모든 게임 관련 화면을 숨기고 경고 표시
            document.querySelectorAll('#gameCanvas, #uiLayer, #bubbleGauge, #mobileControls, #startScreen, #winScreen, #gameOverScreen').forEach(el => {
                el.style.display = 'none';
            });
            orientationAlert.style.display = 'flex';
            gameStarted = false; // 게임 일시 정지
        } else {
            // 세로 모드일 때 경고를 숨기고 필요한 화면 표시
            orientationAlert.style.display = 'none';
            // 게임 시작 화면이 아니면 게임 관련 UI를 다시 보이게 함
            // startScreen.style.display가 "none"이 아니라면 (즉, 화면에 보인다면) display:flex로 설정
            // 그 외의 경우 (게임 중이거나 승리/패배 화면)
            if (startScreen.style.display === 'none' && winScreen.style.display === 'none' && gameOverScreen.style.display === 'none') {
                document.getElementById('gameCanvas').style.display = 'block';
                document.getElementById('uiLayer').style.display = 'flex';
                document.getElementById('bubbleGauge').style.display = 'flex';
                setupMobileControls(); // 모바일 컨트롤러 다시 설정
                if (gameStarted) update(); // 게임이 이미 시작되었던 상태라면 다시 시작
            } else if (startScreen.style.display !== 'none') { // 시작 화면이 보이고 있는 경우
                startScreen.style.display = 'flex';
            } else if (winScreen.style.display !== 'none') { // 승리 화면이 보이고 있는 경우
                winScreen.style.display = 'flex';
            } else if (gameOverScreen.style.display !== 'none') { // 게임 오버 화면이 보이고 있는 경우
                gameOverScreen.style.display = 'flex';
            }
        }
    }

    // 화면 크기 변경 시 방향 확인
    window.addEventListener('resize', checkOrientation);

    function generateLevel() {
      platforms.length = 0; enemies.length = 0;
      platforms.push({ x: 0, y: worldHeight - 20, width: canvas.width });
      let currentY = worldHeight - 100;
      while (currentY > 100) {
        let pWidth = 100 + Math.random() * 50;
        let pX = Math.random() * (canvas.width - pWidth);
        platforms.push({ x: pX, y: currentY, width: pWidth });
        currentY -= 70 + Math.random() * 50;
      }
      const config = stageConfigs[currentStage - 1];
      if (!config) return;
      const spawnPlatforms = [...platforms].slice(1);
      spawnPlatforms.sort(() => 0.5 - Math.random());
      let platformIndex = 0;
      const createEnemy = (type) => {
          if (spawnPlatforms.length === 0) return;
          const platform = spawnPlatforms[platformIndex % spawnPlatforms.length];
          platformIndex++;
          const enemyData = {
              x: platform.x + platform.width / 2 - 17, y: platform.y - 35, width: 35, height: 35,
              direction: Math.random() < 0.5 ? 1 : -1, type: type,
              speed: 1 + Math.random() * currentStage * 0.15,
              dy: 0, groundY: platform.y - 35, jumpPower: -7 - Math.random() * 2,
          };
          if (type === 'fast') { enemyData.speed *= 2; }
          if (type === 'jumper') { enemyData.speed = 0; }
          enemies.push(enemyData);
      };
      for(let i=0; i<config.normal; i++) createEnemy('normal');
      for(let i=0; i<config.fast; i++) createEnemy('fast');
      for(let i=0; i<config.jumper; i++) createEnemy('jumper');
      const topPlatform = platforms.reduce((prev, curr) => (curr.y < prev.y ? curr : prev), platforms[0]);
      goal.x = topPlatform.x + (topPlatform.width / 2) - (goal.width / 2);
      goal.y = topPlatform.y - goal.height - 15;
    }

    function startGame() {
      startScreen.style.display = 'none';
      winScreen.style.display = 'none';
      gameOverScreen.style.display = 'none';
      gameStarted = true; score = 0; currentStage = 1; baby.lives = 3;
      generateLevel();
      resetPlayerPosition();
      bgm.currentTime = 0; bgm.play().catch(e => console.log("BGM 재생 오류:", e));
      update();
    }
    startButton.addEventListener('click', startGame);
    restartButton.addEventListener('click', startGame);
    restartButtonGO.addEventListener('click', startGame);

    function resetPlayerPosition() {
        stageTimer = 20; baby.x = canvas.width / 2 - 25; baby.y = worldHeight - 80;
        baby.dy = 0; camera.y = worldHeight - canvas.height;
        baby.bubblesLeft = baby.maxBubbles;
    }

    function handleLoseLife() {
        baby.lives--;
        if (baby.lives <= 0) {
            showGameOver();
        } else {
            resetPlayerPosition();
        }
    }

    function updateAndShowRanking(playerName, targetElement) {
        let scores = JSON.parse(localStorage.getItem('babyJumperScores')) || [];
        scores.push({ name: playerName, score: score });
        scores.sort((a, b) => b.score - a.score);
        scores = scores.slice(0, 5);
        localStorage.setItem('babyJumperScores', JSON.stringify(scores));
        let rankingHtml = '<h3>🏆 Top 5 Scores 🏆</h3><ol>';
        rankingHtml += scores.map(s => `<li>${s.name}: ${s.score}</li>`).join('');
        rankingHtml += '</ol>';
        targetElement.innerHTML = rankingHtml;
    }

    function showGameOver() {
        gameStarted = false;
        bgm.pause();
        const playerName = prompt(`GAME OVER!\nYour Score: ${score}\n\nEnter your name for the ranking:`, "AAA");
        updateAndShowRanking(playerName || "Guest", rankingListGO);
        gameOverScreen.style.display = 'flex';
    }

    function advanceToNextStage() {
        currentStage++;
        if (currentStage > totalStages) {
            showWinScreen();
        } else {
            score += Math.ceil(stageTimer * 10);
            generateLevel();
            resetPlayerPosition();
        }
    }

    function showWinScreen() {
        gameStarted = false;
        bgm.pause();
        const playerName = prompt(`CONGRATULATIONS!\nYour Final Score: ${score}\n\nEnter your name for the ranking:`, "ACE");
        updateAndShowRanking(playerName || "Guest", rankingList);
        winScreen.style.display = 'flex';
    }

    function bubbleJump() {
      if (baby.bubblesLeft > 0 && gameStarted) {
        baby.bubblesLeft--; baby.dy = baby.bubbleJumpPower;
        bubbles.push({x: baby.x + baby.width / 2, y: baby.y + baby.height, radius: 15, life: 30});
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.translate(0, -camera.y); /* 여전히 Y축으로만 카메라 이동 */
      platforms.forEach(p => ctx.drawImage(platformImg, p.x, p.y, p.width, 20));
      ctx.filter = 'sepia(1) saturate(10) hue-rotate(-50deg) brightness(1.1)';
      ctx.drawImage(goalImg, goal.x, goal.y, goal.width, goal.height);
      ctx.filter = 'none';
      enemies.forEach(e => ctx.drawImage(dragonImg, e.x, e.y, e.width, e.height));
      ctx.drawImage(babyImg, baby.x, baby.y, baby.width, baby.height);
      bubbles.forEach((b, index) => {
        b.y += 2; b.radius *= 0.95; b.life--;
        ctx.globalAlpha = b.life / 30;
        ctx.drawImage(bubbleImg, b.x - b.radius, b.y - b.radius, b.radius * 2, b.radius * 2);
        if (b.life <= 0) bubbles.splice(index, 1);
      });
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    function drawUI() {
        stageDisplay.textContent = `Stage ${currentStage}`;
        scoreText.textContent = `Score: ${score}`;
        livesDisplay.textContent = '❤️ ' + baby.lives;
        timerDisplay.textContent = '⏰ ' + Math.ceil(stageTimer);
        bubbleGauge.innerHTML = '';
        for(let i = 0; i < baby.maxBubbles; i++) {
            const img = document.createElement('img');
            img.src = './bubble.png';
            img.className = 'bubble-icon';
            if (i >= baby.bubblesLeft) img.classList.add('empty');
            bubbleGauge.appendChild(img);
        }
    }

    function update(time = 0) {
      if (!gameStarted || window.innerWidth > window.innerHeight) return; // 게임이 시작되지 않았거나 가로 모드일 때 중단
      deltaTime = (time - lastTime) / 1000; lastTime = time;
      stageTimer -= deltaTime;
      if (stageTimer <= 0) { handleLoseLife(); }
      baby.x += baby.dx; baby.dy += baby.gravity; baby.y += baby.dy;
      const cameraTargetY = baby.y - canvas.height / 2;
      camera.y += (cameraTargetY - camera.y) * camera.lerpFactor;
      if (camera.y < 0) camera.y = 0;
      if (camera.y > worldHeight - canvas.height) { camera.y = worldHeight - canvas.height; }

      // 아기가 화면 밖으로 나가지 않도록 가로 경계 제한
      if (baby.x < 0) baby.x = 0;
      if (baby.x + baby.width > canvas.width) baby.x = canvas.width - baby.width;

      if (baby.dy > 0) {
        platforms.forEach(p => {
          if (baby.x + baby.width > p.x && baby.x < p.x + p.width &&
              baby.y + baby.height > p.y && baby.y < p.y + 20) {
            baby.y = p.y - baby.height; baby.dy = 0; baby.isJumping = false;
          }
        });
      }
      enemies.forEach(e => {
        switch(e.type) {
            case 'normal': case 'fast':
                e.x += e.speed * e.direction;
                if(e.x < 0 || e.x + e.width > canvas.width) e.direction *= -1;
                break;
            case 'jumper':
                e.dy += baby.gravity * 0.5; e.y += e.dy;
                if (e.y > e.groundY && e.dy > 0) { e.y = e.groundY; e.dy = e.jumpPower; }
                break;
        }
        if (baby.x < e.x + e.width && baby.x + baby.width > e.x &&
            baby.y < e.y + e.height && baby.y + baby.height > e.y) {
            handleLoseLife();
        }
      });

      if (baby.y > worldHeight) { handleLoseLife(); }
      if (baby.y + baby.height < 0) { baby.y = -baby.height; baby.dy = 1; }
      if (baby.x < goal.x + goal.width && baby.x + baby.width > goal.x &&
          baby.y < goal.y + goal.height && baby.y + baby.height > goal.y) {
        advanceToNextStage();
      }
      draw();
      drawUI();
      requestAnimationFrame(update);
    }

    // [모바일] 터치 컨트롤러 로직
    function setupMobileControls() {
        const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const mobileControlsDiv = document.getElementById('mobileControls');
        if (!isMobile) {
            mobileControlsDiv.style.display = 'none'; // 모바일이 아니면 숨김
            return;
        }
        // 가로 모드일 때는 숨김 (CSS에서 이미 처리하지만, JS에서도 안전하게)
        if (window.innerWidth > window.innerHeight) {
            mobileControlsDiv.style.display = 'none';
        } else {
            mobileControlsDiv.style.display = 'flex'; // 세로 모드일 때만 표시
        }

        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const jumpBtn = document.getElementById('jumpBtn');
        const bubbleJumpBtn = document.getElementById('bubbleJumpBtn');

        // 기존 이벤트 리스너 제거 (중복 등록 방지)
        leftBtn.removeEventListener('touchstart', handleLeftTouchStart);
        leftBtn.removeEventListener('touchend', handleLeftTouchEnd);
        rightBtn.removeEventListener('touchstart', handleRightTouchStart);
        rightBtn.removeEventListener('touchend', handleRightTouchEnd);
        jumpBtn.removeEventListener('touchstart', handleJumpTouchStart);
        bubbleJumpBtn.removeEventListener('touchstart', handleBubbleJumpTouchStart);

        // 새로운 (또는 다시) 이벤트 리스너 등록
        leftBtn.addEventListener('touchstart', handleLeftTouchStart);
        leftBtn.addEventListener('touchend', handleLeftTouchEnd);
        rightBtn.addEventListener('touchstart', handleRightTouchStart);
        rightBtn.addEventListener('touchend', handleRightTouchEnd);
        jumpBtn.addEventListener('touchstart', handleJumpTouchStart);
        bubbleJumpBtn.addEventListener('touchstart', handleBubbleJumpTouchStart);
    }

    // 터치 이벤트 핸들러 함수를 분리하여 remove/add 가능하게 함
    function handleLeftTouchStart(e) { e.preventDefault(); if (gameStarted && window.innerWidth < window.innerHeight) baby.dx = -baby.speed; }
    function handleLeftTouchEnd(e) { e.preventDefault(); if (gameStarted) baby.dx = 0; }
    function handleRightTouchStart(e) { e.preventDefault(); if (gameStarted && window.innerWidth < window.innerHeight) baby.dx = baby.speed; }
    function handleRightTouchEnd(e) { e.preventDefault(); if (gameStarted) baby.dx = 0; }
    function handleJumpTouchStart(e) { e.preventDefault(); if (gameStarted && !baby.isJumping && window.innerWidth < window.innerHeight) { baby.dy = baby.jumpPower; baby.isJumping = true; } }
    function handleBubbleJumpTouchStart(e) { e.preventDefault(); if (gameStarted && window.innerWidth < window.innerHeight) bubbleJump(); }


    setupMobileControls(); // 초기 호출

    // 키보드 입력 (가로 모드일 때는 작동하지 않도록 추가 조건)
    document.addEventListener('keydown', e => {
      if (!gameStarted || window.innerWidth > window.innerHeight) return;
      if (e.key === 'ArrowRight') baby.dx = baby.speed;
      if (e.key === 'ArrowLeft') baby.dx = -baby.speed;
      if ((e.key === 'a' || e.key === 'ㅁ') && !baby.isJumping) {
        baby.dy = baby.jumpPower; baby.isJumping = true;
      }
      if (e.key === ' ') { e.preventDefault(); bubbleJump(); }
    });
    document.addEventListener('keyup', e => {
      if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') baby.dx = 0;
    });

    // 게임 리소스 로딩
    const allGameImages = [babyImg, platformImg, bubbleImg, goalImg, dragonImg];
    const imagePromises = allGameImages.map(img => new Promise((resolve, reject) => {
        if (img.complete) resolve();
        else { img.onload = resolve; img.onerror = reject; }
    }));
    const audioPromise = new Promise((resolve, reject) => {
        bgm.oncanplaythrough = resolve; bgm.onerror = reject;
    });

    Promise.all(imagePromises,).then(() => {
      startButton.disabled = false; startButton.textContent = 'Start Game';
      checkOrientation(); // 이미지 로딩 후에도 방향 체크
    }).catch(error => {
      startButton.textContent = '에러! 새로고침 해주세요'; startButton.style.backgroundColor = 'red';
    });

    // 페이지 로드 시 초기 방향 체크
    window.addEventListener('load', checkOrientation);

  </script>
</body>
</html>