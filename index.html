<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Baby Jumper "Jehee" - Final Version</title>

  <link rel="manifest" href="./manifest.json">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <style>
    body { margin: 0; overflow: hidden; font-family: 'Arial', sans-serif; background-color: #f0f0f0; }
    canvas {
        background: #d0f4f7;
        display: block;
        height: 100vh; /* 뷰포트 높이에 꽉 맞춤 */
        width: auto; /* 비율에 따라 너비 자동 조절 */
        max-width: 100vw; /* 최대 너비는 뷰포트 너비로 제한 */
        aspect-ratio: 4 / 3; /* 내부 게임 해상도(800x600)의 비율을 유지 */
        margin: 0 auto; /* 중앙 정렬 */
    }
    #uiLayer {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px; /* 가로 전체를 차지 */
      display: flex;
      justify-content: space-between; /* 양쪽 끝으로 정렬 */
      align-items: flex-start; /* 상단 정렬 (아이템들이 위에서부터 쌓이도록) */
      color: #0b3c5d;
      font-size: 24px;
      font-weight: bold;
      pointer-events: none;
      z-index: 15; /* 게임 화면 위에 오도록 */
      background-color: transparent; /* 배경 제거 */
      padding: 10px 20px;
      border-radius: 10px;
      box-shadow: none; /* 그림자 제거 */
    }
    #leftUI {
        display: flex;
        flex-direction: column; /* 세로로 쌓이도록 변경 */
        gap: 5px; /* Stage와 Score 간격 */
        align-items: flex-start; /* 왼쪽 정렬 */
    }
    
    /* 중요: #bubbleGauge의 공통 스타일을 #leftUI #bubbleGauge보다 위로 이동하고,
       #leftUI #bubbleGauge가 더 구체적인 스타일을 갖도록 합니다. */
    #bubbleGauge {
        display: flex;
        gap: 5px;
        align-items: center;
        z-index: 15;
        background-color: transparent; /* 배경 제거 */
        padding: 0; /* 패딩 제거 */
        box-shadow: none; /* 그림자 제거 */
    }
    
    /* #leftUI 안에 있을 때의 #bubbleGauge 스타일 (더 구체적) */
    #leftUI #bubbleGauge {
        margin-top: 10px; /* Stage/Score 아래로 약간의 간격 */
        align-self: flex-start; /* 왼쪽 정렬 유지 */
    }


    #rightUI {
        display: flex;
        flex-direction: column; /* 세로로 쌓이도록 변경 */
        gap: 5px; /* 목숨, 시간, 버블 갯수 간격 */
        align-items: flex-end; /* 오른쪽 정렬 */
    }

    .bubble-icon { width: 30px; height: 30px; opacity: 1; transition: opacity 0.2s; }
    .bubble-icon.empty { opacity: 0.2; }

    /* Pacifier Gauge 스타일 추가 */
    #pacifierGauge {
        display: flex;
        gap: 5px;
        align-items: center;
        z-index: 15;
        background-color: transparent;
        padding: 0;
        box-shadow: none;
    }
    .pacifier-icon {
        width: 30px; /* 쪽쪽이 아이콘 크기 */
        height: 30px;
        opacity: 1;
        transition: opacity 0.2s;
    }
    .pacifier-icon.empty {
        opacity: 0.2;
    }
    .pacifier-count { /* 쪽쪽이 숫자 스타일 */
        font-size: 24px;
        font-weight: bold;
        color: #0b3c5d;
        margin-left: 5px;
    }
    /* 새로운 HUD 행 (하트와 쪽쪽이) */
    #topRightHudRow {
        display: flex;
        align-items: center;
        gap: 15px; /* 하트와 쪽쪽이 사이 간격 */
    }


    #startScreen, #winScreen, #gameOverScreen {
      position: absolute; width: 100%; height: 100%;
      background: linear-gradient(to bottom, #a8e0f7, #d9f7fc);
      display: flex; align-items: center; justify-content: center;
      flex-direction: column; z-index: 10; text-align: center;
    }
    #gameOverScreen { background: linear-gradient(to bottom, #5c5c5c, #333333); }
    #startScreen h1, #winScreen h1, #gameOverScreen h1 { font-size: 64px; color: #ff9f1c; margin-bottom: 20px; }
    #gameOverScreen h1 { color: #ff4d6d; }
    #startScreen p, #winScreen p, #gameOverScreen p { font-size: 20px; color: #3282b8; margin-bottom: 30px; }
    #gameOverScreen p { color: #cccccc; }
    #startButton, #restartButton, #restartButtonGO {
      padding: 15px 40px; font-size: 24px;
      background-color: #ff9f1c; color: white;
      border: 2px solid #e68a00; border-radius: 12px; cursor: pointer;
      box-shadow: 0 4px #e68a00;
    }
    .rankingList {
      font-size: 18px; color: #333; margin: 20px 0; text-align: left;
      background: white; padding: 15px; border-radius: 10px; width: 300px;
    }
    .rankingList h3 { margin-top: 0; text-align: center;}

    /* [모바일] 터치 컨트롤 버튼 스타일 */
    #mobileControls {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 120px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-sizing: border-box;
        padding: 20px;
        z-index: 20;
        user-select: none;
    }
    /* 좌우 이동 버튼을 감싸는 새로운 div */
    #moveBtns {
        display: flex;
        gap: 5px; /* 좌우 이동 버튼 간 간격 최소화 */
    }
    #actionBtns {
        display: flex;
        flex-direction: row; /* 액션 버튼들을 수평으로 정렬 */
        align-items: flex-end; /* 하단 정렬 (버튼이 바닥에 붙도록) */
        gap: 20px; /* BUBBLE과 JUMP 그룹 사이 간격 유지 */
    }
    /* JUMP와 SHOOT를 묶는 컨테이너 */
    #jumpShootBtns {
        display: flex;
        flex-direction: column; /* 세로로 쌓이도록 */
        align-items: center; /* 내부 버튼 가운데 정렬 */
        gap: 10px; /* SHOOT와 JUMP 버튼 간 간격 */
    }

    #leftBtn, #rightBtn, #jumpBtn, #bubbleJumpBtn, #shootBtn { 
        width: 70px;
        height: 70px;
        background-color: rgba(255, 159, 28, 0.7);
        color: white;
        font-size: 24px;
        font-weight: bold;
        display: flex;
        justify-content: center;
        align-items: center;
        border-radius: 50%;
        border: 3px solid rgba(230, 138, 0, 0.9);
        box-shadow: 0 4px rgba(230, 138, 0, 0.9);
    }
    /* 버튼 내부 이미지 스타일 */
    #mobileControls img {
        width: 100%; 
        height: 100%;
        object-fit: contain; 
        padding: 5px; 
        box-sizing: border-box;
    }


    /* 세로 모드일 때 보여줄 알림 (기본적으로는 숨김) */
    #orientation-alert {
      display: flex;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      font-size: 28px;
      text-align: center;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      padding: 20px;
      box-sizing: border-box;
    }

    #orientation-alert img {
        width: 80px;
        height: 80px;
        margin-bottom: 20px;
    }

    /* 가로 모드일 때 #orientation-alert를 숨김 */
    @media screen and (orientation: landscape) {
      #orientation-alert {
        display: none;
      }
      /* 가로 모드일 때 게임과 다른 UI를 표시 */
      #gameCanvas, #uiLayer, #mobileControls { 
        display: flex; 
      }
      #gameCanvas {
        display: block; 
      }
    }

    /* 세로 모드일 때 게임 관련 UI 숨김 */
    @media screen and (orientation: portrait) {
      #gameCanvas, #uiLayer, #mobileControls,
      #startScreen, #winScreen, #gameOverScreen {
        display: none; 
      }
      #orientation-alert {
        display: flex;
      }
    }

    /* 초기 로딩 시 startScreen만 보이도록 설정 (다른 화면은 기본적으로 숨겨짐) */
    #startScreen { display: flex; }
    #winScreen, #gameOverScreen { display: none; }
    #uiLayer, #mobileControls, #gameCanvas { display: none; }
  </style>
</head>
<body>
  <div id="startScreen">
    <h1>Baby Jumper "Jehee"</h1>
    <p>5개의 버블로 20개의 스테이지를 정복하세요!</p>
    <p><strong>Controls:</strong> ← → to move, A to Jump, SPACE to Bubble Jump</p>
    <button id="startButton" disabled>게임 로딩중...</button>
  </div>

  <div id="winScreen">
    <h1>CONGRATULATIONS!</h1>
    <p>모든 스테이지를 클리어했습니다!</p>
    <div id="rankingList" class="rankingList"></div>
    <button id="restartButton">Play Again</button>
  </div>

  <div id="gameOverScreen">
    <h1>GAME OVER</h1>
    <p>현재 스코어 : <span id="finalScoreGO"></span></p>
    <div id="rankingListGO" class="rankingList"></div>
    <button id="restartButtonGO">Try Again</button>
  </div>

  <div id="uiLayer">
    <div id="leftUI">
      <div id="stageDisplay">Stage 1</div>
      <div id="score">Score: 0</div>
      <div id="bubbleGauge"></div> 
    </div>
    <div id="rightUI">
      <div id="topRightHudRow">
          <div id="livesDisplay"></div> 
          <div id="pacifierGauge"></div> 
      </div>
      <div id="timerDisplay">⏰ 20</div>
    </div>
  </div>

  <canvas id="gameCanvas"></canvas>
  <audio id="bgm" src="./bgm.mp3" loop></audio>

  <div id="mobileControls">
    <div id="moveBtns">
      <div id="leftBtn">←</div>
      <div id="rightBtn">→</div>
    </div>
    <div id="actionBtns">
      <div id="bubbleJumpBtn">BUBBLE</div>
      <div id="jumpShootBtns">
        <div id="shootBtn">SHOOT</div> 
        <div id="jumpBtn">JUMP</div>
      </div>
    </div>
  </div>

  <div id="orientation-alert">
    <img src="./rotate_icon.png" alt="Rotate to Landscape Mode">
    <p>가로 모드로 전환해 주세요.</p>
    <p>(Please switch to landscape mode)</p>
  </div>


  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas ? canvas.getContext('2d') : null;
    if (canvas) {
        canvas.width = 800; canvas.height = 600;
    }

    let worldHeight = (canvas ? canvas.height : 600) * 2; 

    const camera = {
      y: worldHeight - (canvas ? canvas.height : 600),
      lerpFactor: 0.08
    };

    const babyImg = new Image(); babyImg.src = "./baby.png";
    // 새 이미지 로드: 초사이언 아기
    const superBabyImg = new Image(); superBabyImg.src = "./superbaby.png";
    const platformImg = new Image(); platformImg.src = "./platform.png";
    const bubbleImg = new Image(); bubbleImg.src = "./bubble.png";
    const goalImg = new Image(); goalImg.src = "./milk.png";
    const dragonImg = new Image(); dragonImg.src = "./dragon.png";
    const redDragonImg = new Image(); redDragonImg.src = "./reddragon.png";
    const goldDragonImg = new Image(); goldDragonImg.src = "./golddragon.png";
    const heartImg = new Image(); heartImg.src = "./heart.png";
    const diaperImg = new Image(); diaperImg.src = "./diaper.png"; // 기저귀 아이템 이미지
    const pacifierProjectileImg = new Image(); pacifierProjectileImg.src = "./pacifier.png";
    const pacifierItemImg = new Image(); pacifierItemImg.src = "./pacifier.png";


    const bgm = document.getElementById('bgm');

    let gameStarted = false, score = 0;
    let currentStage = 1;
    const totalStages = 20;
    let stageTimer = 20;
    let lastTime = 0, deltaTime = 0;

    const BUBBLE_RECHARGE_INTERVAL = 5000; 
    let lastBubbleRechargeTime = 0;

    // 초사이언 변신 관련 변수 추가
    const SUPER_BABY_DURATION = 8000; // 8초 (밀리초)
    let isSuperBaby = false;
    let superBabyStartTime = 0;

    const baby = {
      x: (canvas ? canvas.width : 800) / 2 - 25, y: worldHeight - 80,
      width: 50, height: 50, speed: 4,
      dx: 0, dy: 0, gravity: 0.4, jumpPower: -10,
      isJumping: false, 
      bubblesLeft: 5, 
      maxBubbles: 5, 
      bubbleJumpPower: -12,
      lives: 5,
      pacifiersLeft: 0,   
      maxPacifiers: 50,  
      lastShotTime: 0,    
      shootCoolDown: 200  
    };

    // diaperItems 배열 추가 (기저귀 아이템)
    const platforms = [], playerBubbles = [], enemies = [], enemyBubbles = [], hearts = [], diapers = [], pacifiers = [], pacifierItems = []; 
    const goal = { x: (canvas ? canvas.width : 800) / 2 - 20, y: 50, width: 40, height: 40 };

    const stageConfigs = [
        { stage: 1, normal: 0, fast: 0, jumper: 0, redDragon: 0, goldDragon: 0, lengthMultiplier: 1, timer: 20, heart: false, pacifierItem: false, diaperItem: false },
        { stage: 2, normal: 1, fast: 0, jumper: 0, redDragon: 0, goldDragon: 0, lengthMultiplier: 1, timer: 20, heart: false, pacifierItem: false, diaperItem: false },
        { stage: 3, normal: 2, fast: 0, jumper: 0, redDragon: 0, goldDragon: 0, lengthMultiplier: 1, timer: 20, heart: false, pacifierItem: false, diaperItem: false },
        { stage: 4, normal: 3, fast: 0, jumper: 0, redDragon: 0, goldDragon: 0, lengthMultiplier: 1, timer: 20, heart: false, pacifierItem: false, diaperItem: false },
        { stage: 5, normal: 4, fast: 0, jumper: 0, redDragon: 0, goldDragon: 0, lengthMultiplier: 1, timer: 20, heart: false, pacifierItem: false, diaperItem: false }, 
        { stage: 6, normal: 3, fast: 2, jumper: 0, redDragon: 0, goldDragon: 0, lengthMultiplier: 1, timer: 20, heart: false, pacifierItem: false, diaperItem: false },
        { stage: 7, normal: 3, fast: 2, jumper: 1, redDragon: 0, goldDragon: 0, lengthMultiplier: 1, timer: 20, heart: false, pacifierItem: false, diaperItem: false },
        { stage: 8, normal: 7, fast: 2, jumper: 1, redDragon: 0, goldDragon: 0, lengthMultiplier: 1, timer: 20, heart: false, pacifierItem: true, diaperItem: false }, 
        { stage: 9, normal: 6, fast: 4, jumper: 2, redDragon: 0, goldDragon: 0, lengthMultiplier: 1, timer: 20, heart: false, pacifierItem: false, diaperItem: true }, // 9단계에 기저귀 아이템 추가
        { stage: 10, normal: 4, fast: 8, jumper: 3, redDragon: 0, goldDragon: 0, lengthMultiplier: 1, timer: 20, heart: false, pacifierItem: false, diaperItem: false },
        { stage: 11, normal: 4, fast: 10, jumper: 3, redDragon: 3, goldDragon: 0, lengthMultiplier: 1.5, timer: 30, heart: true, pacifierItem: false, diaperItem: false },
        { stage: 12, normal: 3, fast: 12, jumper: 5, redDragon: 5, goldDragon: 0, lengthMultiplier: 1.5, timer: 30, heart: true, pacifierItem: false, diaperItem: true }, // 12단계에 기저귀 아이템 추가
        { stage: 13, normal: 3, fast: 12, jumper: 5, redDragon: 1, goldDragon: 0, lengthMultiplier: 1.5, timer: 30, heart: true, pacifierItem: true, diaperItem: false }, 
        { stage: 14, normal: 3, fast: 12, jumper: 5, redDragon: 3, goldDragon: 0, lengthMultiplier: 1.5, timer: 30, heart: true, pacifierItem: false, diaperItem: false },
        { stage: 15, normal: 3, fast: 12, jumper: 5, redDragon: 5, goldDragon: 0, lengthMultiplier: 1.5, timer: 30, heart: true, pacifierItem: false, diaperItem: false },
        { stage: 16, normal: 3, fast: 12, jumper: 6, redDragon: 7, goldDragon: 0, lengthMultiplier: 1.5, timer: 30, heart: true, pacifierItem: false, diaperItem: false },
        { stage: 17, normal: 3, fast: 12, jumper: 6, redDragon: 10, goldDragon: 0, lengthMultiplier: 1.5, timer: 30, heart: true, pacifierItem: false, diaperItem: true }, // 17단계에 기저귀 아이템 추가
        { stage: 18, normal: 5, fast: 15, jumper: 6, redDragon: 10, goldDragon: 0, lengthMultiplier: 1.5, timer: 30, heart: true, pacifierItem: true, diaperItem: false }, 
        { stage: 19, normal: 5, fast: 17, jumper: 8, redDragon: 12, goldDragon: 0, lengthMultiplier: 1.5, timer: 30, heart: true, pacifierItem: false, diaperItem: false },
        { stage: 20, normal: 0, fast: 17, jumper: 8, redDragon: 12, goldDragon: 1, lengthMultiplier: 1.5, timer: 30, heart: true, pacifierItem: false, diaperItem: false } 
    ];

    let startButton, restartButton, restartButtonGO, startScreen, winScreen, gameOverScreen,
        stageDisplay, scoreText, bubbleGauge, livesDisplay, timerDisplay, rankingList, rankingListGO,
        orientationAlert, pacifierGauge, topRightHudRow, finalScoreGO;

    let bubbleIcons = [];
    let pacifierIconImg;
    let pacifierCountSpan;

    function initializeUIElements() {
        startButton = document.getElementById('startButton');
        restartButton = document.getElementById('restartButton');
        restartButtonGO = document.getElementById('restartButtonGO');
        startScreen = document.getElementById('startScreen');
        winScreen = document.getElementById('winScreen');
        gameOverScreen = document.getElementById('gameOverScreen');
        stageDisplay = document.getElementById('stageDisplay');
        scoreText = document.getElementById('score');
        bubbleGauge = document.getElementById('bubbleGauge');
        livesDisplay = document.getElementById('livesDisplay');
        timerDisplay = document.getElementById('timerDisplay');
        rankingList = document.getElementById('rankingList');
        rankingListGO = document.getElementById('rankingListGO');
        orientationAlert = document.getElementById('orientation-alert');
        pacifierGauge = document.getElementById('pacifierGauge'); 
        topRightHudRow = document.getElementById('topRightHudRow');
        finalScoreGO = document.getElementById('finalScoreGO'); 

        if (bubbleGauge) { 
            bubbleGauge.innerHTML = ''; 
            for(let i = 0; i < baby.maxBubbles; i++) { 
                const img = document.createElement('img');
                img.src = './bubble.png';
                img.className = 'bubble-icon';
                bubbleGauge.appendChild(img);
                bubbleIcons.push(img); 
            }
        }

        if (pacifierGauge) { 
            pacifierGauge.innerHTML = ''; 
            pacifierIconImg = document.createElement('img');
            pacifierIconImg.src = './pacifier.png'; 
            pacifierIconImg.className = 'pacifier-icon';
            pacifierGauge.appendChild(pacifierIconImg);

            pacifierCountSpan = document.createElement('span');
            pacifierCountSpan.className = 'pacifier-count';
            pacifierGauge.appendChild(pacifierCountSpan);
        }

        if (startButton) startButton.addEventListener('click', startGame);
        if (restartButton) restartButton.addEventListener('click', startGame);
        if (restartButtonGO) restartButtonGO.addEventListener('click', startGame);
    }


    function enterFullscreen() {
        const elem = document.documentElement;
        if (elem.requestFullscreen) {
            elem.requestFullscreen();
        } else if (elem.mozRequestFullScreen) {
            elem.mozRequestFullScreen();
        } else if (elem.webkitRequestFullscreen) {
            elem.webkitRequestFullscreen();
        } else if (elem.msRequestFullscreen) {
            elem.msRequestFullscreen();
        }
    }

    function setUIContainersDisplay(displayValue) {
        if (document.getElementById('gameCanvas')) document.getElementById('gameCanvas').style.display = displayValue;
        if (document.getElementById('uiLayer')) document.getElementById('uiLayer').style.display = displayValue;
        if (document.getElementById('mobileControls')) document.getElementById('mobileControls').style.display = displayValue;
    }

    let currentGameState = 'startScreen'; 

    function checkOrientation() {
        if (window.innerWidth < window.innerHeight) {
            setUIContainersDisplay('none');
            if (startScreen) startScreen.style.display = 'none';
            if (winScreen) winScreen.style.display = 'none';
            if (gameOverScreen) gameOverScreen.style.display = 'none';
            if (orientationAlert) orientationAlert.style.display = 'flex';
            
            gameStarted = false; 
            if (bgm) bgm.pause();
        } else {
            if (orientationAlert) orientationAlert.style.display = 'none';

            if (currentGameState === 'playing') {
                setUIContainersDisplay('flex'); 
                if (canvas) canvas.style.display = 'block'; 
                setupMobileControls();
                if (bgm) bgm.play().catch(e => console.log("BGM 재생 오류:", e));
            } else if (currentGameState === 'winScreen') {
                setUIContainersDisplay('none');
                if (winScreen) winScreen.style.display = 'flex';
            } else if (currentGameState === 'gameOverScreen') {
                setUIContainersDisplay('none');
                if (gameOverScreen) gameOverScreen.style.display = 'flex';
            } else { 
                setUIContainersDisplay('none');
                if (startScreen) startScreen.style.display = 'flex';
            }
        }
    }

    window.addEventListener('resize', checkOrientation);

    function generateLevel() {
      platforms.length = 0; enemies.length = 0; enemyBubbles.length = 0; 
      hearts.length = 0; 
      diapers.length = 0; // 기저귀 아이템 배열 초기화
      pacifiers.length = 0; 
      pacifierItems.length = 0; 

      const config = stageConfigs[currentStage - 1];
      if (!config) return;

      worldHeight = canvas.height * 2 * config.lengthMultiplier;
      camera.y = worldHeight - canvas.height; 

      platforms.push({ x: 0, y: worldHeight - 20, width: canvas.width });
      
      let currentY = worldHeight - 100;
      while (currentY > 100 + (worldHeight - canvas.height * 2) / 2) {
        let pWidth = 100 + Math.random() * 50;
        let pX = Math.random() * (canvas.width - pWidth);
        platforms.push({ x: pX, y: currentY, width: pWidth });
        currentY -= 70 + Math.random() * 50;
      }

      const spawnPlatforms = [...platforms].slice(1);
      spawnPlatforms.sort(() => 0.5 - Math.random());
      let platformIndex = 0;

      const createEnemy = (type, isBoss = false) => {
          let platform;
          if (isBoss) { 
              const topPlatform = platforms.reduce((prev, curr) => (curr.y < prev.y ? curr : prev), platforms[0]);
              let bossPlatform = platforms.find(p => p.y < 200 && p.width > 150); 
              if (!bossPlatform) { 
                  bossPlatform = { x: canvas.width / 2 - 75, y: topPlatform.y + 50, width: 150 };
                  platforms.push(bossPlatform);
              }
              platform = bossPlatform;
          } else { 
              if (spawnPlatforms.length === 0) return;
              platform = spawnPlatforms[platformIndex % spawnPlatforms.length];
              platformIndex++;
          }
          
          let enemyWidth = 35;
          let enemyHeight = 35;
          let enemySpeed = 1 + Math.random() * currentStage * 0.15;
          let jumpPower = -7 - Math.random() * 2;
          let image = dragonImg;
          let shootInterval = 0;

          if (type === 'fast') { enemySpeed *= 2; }
          if (type === 'jumper') { enemySpeed = 0; }
          if (type === 'redDragon') { 
            image = redDragonImg; 
            shootInterval = 1000 + Math.random() * 1500;
          }
          if (type === 'goldDragon') {
            image = goldDragonImg;
            enemyWidth *= 2;
            enemyHeight *= 2;
            enemySpeed = 1; 
            shootInterval = 800 + Math.random() * 1200;
          }

          enemies.push({
              x: platform.x + platform.width / 2 - enemyWidth / 2, 
              y: platform.y - enemyHeight, 
              width: enemyWidth, 
              height: enemyHeight,
              direction: Math.random() < 0.5 ? 1 : -1, 
              type: type,
              speed: enemySpeed,
              dy: 0, 
              groundY: platform.y - enemyHeight, 
              jumpPower: jumpPower,
              image: image,
              lastShotTime: 0,
              shootInterval: shootInterval
          });
      };

      for(let i=0; i<config.normal; i++) createEnemy('normal');
      for(let i=0; i<config.fast; i++) createEnemy('fast');
      for(let i=0; i<config.jumper; i++) createEnemy('jumper');
      for(let i=0; i<config.redDragon; i++) createEnemy('redDragon');
      
      if (config.goldDragon > 0 && currentStage === 20) {
          createEnemy('goldDragon', true);
      }

      if (config.heart) {
          const suitablePlatforms = platforms.filter(p => p.y < worldHeight - 200 && p.y > 200);
          if (suitablePlatforms.length > 0) {
              const heartPlatform = suitablePlatforms[Math.floor(Math.random() * suitablePlatforms.length)];
              hearts.push({
                  x: heartPlatform.x + heartPlatform.width / 2 - 20, 
                  y: heartPlatform.y - 40, 
                  width: 30, height: 30, 
                  collected: false
              });
          }
      }

      if (config.pacifierItem) { 
          const suitablePlatforms = platforms.filter(p => p.y < worldHeight - 200 && p.y > 200);
          if (suitablePlatforms.length > 0) {
              const pacifierItemPlatform = suitablePlatforms[Math.floor(Math.random() * suitablePlatforms.length)];
              pacifierItems.push({ 
                  x: pacifierItemPlatform.x + pacifierItemPlatform.width / 2 - 20, 
                  y: pacifierItemPlatform.y - 40, 
                  width: 30, height: 30, 
                  collected: false
              });
          }
      }
      
      // 기저귀 아이템 배치 로직 (스테이지 9, 12, 17에서만)
      if (config.diaperItem) { 
          const suitablePlatforms = platforms.filter(p => p.y < worldHeight - 200 && p.y > 200);
          if (suitablePlatforms.length > 0) {
              const diaperPlatform = suitablePlatforms[Math.floor(Math.random() * suitablePlatforms.length)];
              diapers.push({ // diapers 배열에 추가
                  x: diaperPlatform.x + diaperPlatform.width / 2 - 20, 
                  y: diaperPlatform.y - 40, 
                  width: 40, height: 40, // 기저귀 이미지 크기
                  collected: false
              });
          }
      }

      const topPlatform = platforms.reduce((prev, curr) => (curr.y < prev.y ? curr : prev), platforms[0]);
      goal.x = topPlatform.x + (topPlatform.width / 2) - (goal.width / 2);
      goal.y = topPlatform.y - goal.height - 15;
    }

    function startGame() {
      currentGameState = 'playing'; 
      setUIContainersDisplay('flex'); 
      if (canvas) canvas.style.display = 'block'; 
      if (startScreen) startScreen.style.display = 'none';
      if (winScreen) winScreen.style.display = 'none';
      if (gameOverScreen) gameOverScreen.style.display = 'none';
      
      setupMobileControls();

      gameStarted = true; score = 0; currentStage = 1; 
      baby.lives = 5; 
      baby.bubblesLeft = baby.maxBubbles; 
      lastBubbleRechargeTime = 0; 
      baby.pacifiersLeft = 0; 
      baby.lastShotTime = 0; 
      isSuperBaby = false; // 게임 시작 시 초사이언 상태 초기화

      generateLevel(); 
      resetPlayerPosition(); 
      if (bgm) {
          bgm.currentTime = 0; 
          bgm.play().catch(e => {
            console.log("BGM 재생 오류:", e);
          });
      }
      requestAnimationFrame(update); 
      enterFullscreen();
    }

    function resetPlayerPosition() {
        const config = stageConfigs[currentStage - 1];
        stageTimer = config ? config.timer : 20;
        
        if (config) {
            worldHeight = (canvas ? canvas.height : 600) * 2 * config.lengthMultiplier;
        } else {
            worldHeight = (canvas ? canvas.height : 600) * 2; 
        }

        baby.x = (canvas ? canvas.width : 800) / 2 - 25; 
        baby.y = worldHeight - 80; 
        baby.dy = 0; 
        camera.y = worldHeight - (canvas ? canvas.height : 600); 
        baby.bubblesLeft = baby.maxBubbles; 
        lastBubbleRechargeTime = 0; 
        baby.lastShotTime = 0;    
        isSuperBaby = false; // 스테이지 전환 시 초사이언 상태 초기화
    }

    function handleLoseLife() {
        // 초사이언 상태일 때는 목숨을 잃지 않음
        if (isSuperBaby) return; 

        baby.lives--;
        if (baby.lives <= 0) {
            showGameOver();
        } else {
            resetPlayerPosition();
        }
    }

    function updateAndShowRanking(playerName, targetElement) {
        let scores = JSON.parse(localStorage.getItem('babyJumperScores')) || [];
        scores.push({ name: playerName, score: score });
        scores.sort((a, b) => b.score - a.score);
        scores = scores.slice(0, 5);
        localStorage.setItem('babyJumperScores', JSON.stringify(scores));
        let rankingHtml = '<h3>🏆 Top 5 Scores 🏆</h3><ol>';
        rankingHtml += scores.map(s => `<li>${s.name}: ${s.score}</li>`).join('');
        rankingHtml += '</ol>';
        if (targetElement) targetElement.innerHTML = rankingHtml;
    }

    function showGameOver() {
        gameStarted = false;
        currentGameState = 'gameOverScreen'; 
        if (bgm) bgm.pause();
        setUIContainersDisplay('none');
        if (gameOverScreen) gameOverScreen.style.display = 'flex';
        
        if (finalScoreGO) finalScoreGO.textContent = score; 

        const playerName = prompt(`GAME OVER!\nYour Score: ${score}\n\nEnter your name for the ranking:`, "AAA");
        updateAndShowRanking(playerName || "Guest", rankingListGO);
    }

    function advanceToNextStage() {
        score += Math.ceil(stageTimer * 10);

        if (currentStage === 10) {
            score += 300;
        } else if (currentStage === 15) {
            score += 300;
        } else if (currentStage === totalStages) { 
            score += 500; 
            score += baby.lives * 100; 
        }

        currentStage++;
        if (currentStage > totalStages) {
            showWinScreen();
        } else {
            generateLevel(); 
            resetPlayerPosition(); 
        }
    }

    function showWinScreen() {
        gameStarted = false;
        currentGameState = 'winScreen'; 
        if (bgm) bgm.pause();
        setUIContainersDisplay('none');
        if (winScreen) winScreen.style.display = 'flex';

        const playerName = prompt(`CONGRATULATIONS!\nYour Final Score: ${score}\n\nEnter your name for the ranking:`, "ACE");
        updateAndShowRanking(playerName || "Guest", rankingList);
    }

    function bubbleJump() {
      if (baby.bubblesLeft > 0 && gameStarted) {
        baby.bubblesLeft--; 
        baby.dy = baby.bubbleJumpPower;
        playerBubbles.push({x: baby.x + baby.width / 2, y: baby.y + baby.height, radius: 15, life: 30});
      }
    }

    function shootPacifier() {
        if (baby.pacifiersLeft > 0 && gameStarted && (lastTime - baby.lastShotTime > baby.shootCoolDown)) {
            baby.pacifiersLeft--;
            pacifiers.push({ 
                x: baby.x + baby.width / 2 - 10, 
                y: baby.y, 
                width: 20, height: 20, 
                dy: -10, 
                life: 90 
            });
            baby.lastShotTime = lastTime; 
        }
    }


    function draw() {
      if (!ctx) return; 
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.translate(0, -camera.y);

      // 초사이언 상태일 때 화면 필터 적용
      if (isSuperBaby) {
          // 다양한 필터 조합으로 반짝이는 느낌을 낼 수 있습니다.
          // 예시: 밝기, 대비, 색조 회전 등을 조합
          ctx.filter = `brightness(1.5) contrast(1.2) hue-rotate(${Math.sin(lastTime / 100) * 360}deg)`; 
          // ctx.filter = 'saturate(2) hue-rotate(90deg)'; // 다른 시도
          // ctx.filter = 'brightness(1.5) drop-shadow(0 0 10px yellow)'; // 빛나는 그림자
      }


      ctx.fillStyle = '#d0f4f7';
      ctx.fillRect(0, 0, canvas.width, worldHeight);

      platforms.forEach(p => ctx.drawImage(platformImg, p.x, p.y, p.width, 20));
      
      ctx.filter = 'sepia(1) saturate(10) hue-rotate(-50deg) brightness(1.1)'; 
      ctx.drawImage(goalImg, goal.x, goal.y, goal.width, goal.height);
      ctx.filter = 'none'; // 골 이미지 필터는 여기서 초기화 (아기 필터에 영향 안주도록)

      // 기저귀 아이템 그리기
      diapers.forEach(d => {
          if (!d.collected) {
              ctx.drawImage(diaperImg, d.x, d.y, d.width, d.height);
          }
      });
      
      enemies.forEach(e => {
        ctx.drawImage(e.image, e.x, e.y, e.width, e.height);
      });

      hearts.forEach(h => {
          if (!h.collected) { 
              ctx.drawImage(heartImg, h.x, h.y, h.width, h.height);
          }
      });

      pacifierItems.forEach(pItem => {
          if (!pItem.collected) {
              ctx.drawImage(pacifierItemImg, pItem.x, pItem.y, pItem.width, pItem.height);
          }
      });

      // 아기 캐릭터 그리기 (초사이언 상태에 따라 이미지 변경)
      ctx.drawImage(isSuperBaby ? superBabyImg : babyImg, baby.x, baby.y, baby.width, baby.height);
      
      playerBubbles.forEach((b, index) => {
        b.y += 2; b.radius *= 0.95; b.life--;
        ctx.globalAlpha = b.life / 30;
        ctx.drawImage(bubbleImg, b.x - b.radius, b.y - b.radius, b.radius * 2, b.radius * 2);
        if (b.life <= 0) playerBubbles.splice(index, 1);
      });

      enemyBubbles.forEach((b, index) => {
        b.x += b.dx;
        b.y += b.dy;
        b.life--;
        ctx.globalAlpha = b.life / 60;
        ctx.drawImage(bubbleImg, b.x - b.radius, b.y - b.radius, b.radius * 2, b.radius * 2);
        if (b.life <= 0) enemyBubbles.splice(index, 1);
      });

      pacifiers.forEach((p) => {
          ctx.drawImage(pacifierProjectileImg, p.x, p.y, p.width, p.height);
      });

      ctx.globalAlpha = 1;
      ctx.filter = 'none'; // 전체 캔버스 필터를 여기서 다시 초기화
      ctx.restore();
    }

    function drawUI() {
        if (!stageDisplay || !scoreText || !livesDisplay || !timerDisplay || !pacifierCountSpan || !bubbleGauge || bubbleIcons.length === 0) {
            return; 
        }

        stageDisplay.textContent = `Stage ${currentStage} / ${totalStages}`;
        scoreText.textContent = `Score: ${score}`;
        
        livesDisplay.textContent = '❤️ ' + Math.max(0, baby.lives - 1); 
        
        pacifierCountSpan.textContent = baby.pacifiersLeft;

        timerDisplay.textContent = '⏰ ' + Math.ceil(stageTimer);
        
        bubbleIcons.forEach((img, i) => {
            if (i >= baby.bubblesLeft) {
                img.classList.add('empty');
            } else {
                img.classList.remove('empty');
            }
        });
    }

    function update(time = 0) {
      if (!gameStarted || window.innerWidth < window.innerHeight) {
        return; 
      }
      deltaTime = (time - lastTime) / 1000; lastTime = time;
      stageTimer -= deltaTime;
      if (stageTimer <= 0) { handleLoseLife(); }

      // 초사이언 상태 시간 관리
      if (isSuperBaby && time - superBabyStartTime > SUPER_BABY_DURATION) {
          isSuperBaby = false; // 8초가 지나면 초사이언 상태 해제
      }


      if (baby.bubblesLeft < baby.maxBubbles) {
          if (time - lastBubbleRechargeTime > BUBBLE_RECHARGE_INTERVAL) {
              baby.bubblesLeft++;
              lastBubbleRechargeTime = time; 
          }
      } else {
          lastBubbleRechargeTime = time; 
      }
      
      baby.x += baby.dx; 
      baby.dy += baby.gravity; 
      baby.y += baby.dy;

      const cameraTargetY = baby.y - (canvas ? canvas.height : 600) / 2;
      camera.y += (cameraTargetY - camera.y) * camera.lerpFactor;
      if (camera.y < 0) camera.y = 0;
      if (camera.y > worldHeight - (canvas ? canvas.height : 600)) { camera.y = worldHeight - (canvas ? canvas.height : 600); }

      if (baby.x < 0) baby.x = 0;
      if (baby.x + baby.width > (canvas ? canvas.width : 800)) baby.x = (canvas ? canvas.width : 800) - baby.width;

      if (baby.dy > 0) {
        platforms.forEach(p => {
          if (baby.x + baby.width > p.x && baby.x < p.x + p.width &&
              baby.y + baby.height > p.y && baby.y < p.y + 20) {
            baby.y = p.y - baby.height; 
            baby.dy = 0; 
            baby.isJumping = false;
          }
        });
      }

      hearts.forEach((h, index) => {
          if (!h.collected && 
              baby.x < h.x + h.width && baby.x + baby.width > h.x &&
              baby.y < h.y + h.height && baby.y + baby.height > h.y) {
              baby.lives++; 
              h.collected = true; 
          }
      });

      pacifierItems.forEach((pItem, index) => {
          if (!pItem.collected &&
              baby.x < pItem.x + pItem.width && baby.x + baby.width > pItem.x &&
              baby.y < pItem.y + pItem.height && baby.y + baby.height > pItem.y) {
              baby.pacifiersLeft = Math.min(baby.maxPacifiers, baby.pacifiersLeft + 20); 
              pItem.collected = true; 
          }
      });

      // 기저귀 아이템 충돌 처리
      diapers.forEach((d, index) => {
          if (!d.collected &&
              baby.x < d.x + d.width && baby.x + baby.width > d.x &&
              baby.y < d.y + d.height && baby.y + baby.height > d.y) {
              d.collected = true; 
              isSuperBaby = true; // 초사이언 상태 활성화
              superBabyStartTime = time; // 시작 시간 기록
          }
      });


      pacifiers.forEach((p, pIndex) => {
          p.y += p.dy; 
          p.life--;

          if (p.y + p.height < 0 || p.life <= 0) {
              pacifiers.splice(pIndex, 1);
              return; 
          }

          let enemyRemoved = false; 
          for(let i = 0; i < enemies.length; i++) {
              const e = enemies[i];
              if (p.x < e.x + e.width && p.x + p.width > e.x &&
                  p.y < e.y + e.height && p.y + e.height > e.y) { 
                  enemies.splice(i, 1); 
                  pacifiers.splice(pIndex, 1); 
                  score += 20; 
                  enemyRemoved = true; 
                  break; 
              }
          }
          if (enemyRemoved) return; 
      });


      enemies.forEach((e, index) => { 
        switch(e.type) {
            case 'normal': 
            case 'fast':
                e.x += e.speed * e.direction;
                if(e.x < 0 || e.x + e.width > (canvas ? canvas.width : 800)) e.direction *= -1;
                break;
            case 'jumper':
                e.dy += baby.gravity * 0.5; 
                e.y += e.dy;
                if (e.y > e.groundY && e.dy > 0) { 
                    e.y = e.groundY; 
                    e.dy = e.jumpPower; 
                }
                break;
            case 'redDragon':
            case 'goldDragon':
                e.x += e.speed * e.direction;
                if(e.x < 0 || e.x + e.width > (canvas ? canvas.width : 800)) e.direction *= -1;

                if (time - e.lastShotTime > e.shootInterval) {
                    const bubbleRadius = (e.type === 'goldDragon') ? 30 : 15;
                    const bubbleLife = (e.type === 'goldDragon') ? 120 : 60;
                    const bubbleSpeed = (e.type === 'goldDragon') ? 1.5 : 2;
                    
                    const angle = Math.atan2(baby.y + baby.height / 2 - (e.y + e.height / 2), baby.x + baby.width / 2 - (e.x + e.width / 2));
                    enemyBubbles.push({
                        x: e.x + e.width / 2, 
                        y: e.y + e.height / 2, 
                        radius: bubbleRadius, 
                        life: bubbleLife,
                        dx: Math.cos(angle) * bubbleSpeed,
                        dy: Math.sin(angle) * bubbleSpeed
                    });
                    e.lastShotTime = time;
                }
                break;
        }

        // 아기 캐릭터와 적의 충돌 처리 (초사이언 상태일 때)
        if (baby.x < e.x + e.width && baby.x + baby.width > e.x &&
            baby.y < e.y + e.height && baby.y + baby.height > e.y) {
            if (isSuperBaby) {
                // 초사이언 상태일 때 적과 부딪히면 적 제거
                enemies.splice(index, 1);
                score += 50; // 적 제거 시 추가 점수
            } else {
                handleLoseLife(); 
            }
        }
      });

      enemyBubbles.forEach((b, index) => {
          b.x += b.dx;
          b.y += b.dy;
          b.life--;

          if (b.x < -b.radius || b.x > (canvas ? canvas.width : 800) + b.radius || b.y < -b.radius || b.y > worldHeight + b.radius || b.life <= 0) {
              enemyBubbles.splice(index, 1);
              return;
          }

          // 아기 캐릭터와 적 버블의 충돌 처리 (초사이언 상태일 때)
          if (baby.x < b.x + b.radius && baby.x + baby.width > b.x - b.radius &&
              baby.y < b.y + b.radius && baby.y + baby.height > b.y - b.radius) {
              if (isSuperBaby) {
                  // 초사이언 상태일 때 적 버블과 부딪히면 버블 제거
                  enemyBubbles.splice(index, 1);
              } else {
                  handleLoseLife();
                  enemyBubbles.splice(index, 1);
              }
          }
      });

      if (baby.y > worldHeight) { handleLoseLife(); }
      if (baby.y + baby.height < 0) { 
        baby.y = -baby.height; 
        baby.dy = 1; 
      }

      if (baby.x < goal.x + goal.width && baby.x + baby.width > goal.x &&
          baby.y < goal.y + goal.height && baby.y + baby.height > goal.y) {
        advanceToNextStage();
      }
      
      draw();
      drawUI();
      requestAnimationFrame(update);
    }

    // [모바일] 터치 컨트롤러 로직
    function setupMobileControls() {
        const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const mobileControlsDiv = document.getElementById('mobileControls');
        if (!isMobile) {
            if (mobileControlsDiv) mobileControlsDiv.style.display = 'none';
            return;
        }
        
        if (mobileControlsDiv) {
            if (window.innerWidth < window.innerHeight) {
                mobileControlsDiv.style.display = 'none';
            } else {
                mobileControlsDiv.style.display = 'flex';
            }
        }

        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const jumpBtn = document.getElementById('jumpBtn');
        const bubbleJumpBtn = document.getElementById('bubbleJumpBtn');
        const shootBtn = document.getElementById('shootBtn'); 

        if (leftBtn) {
            leftBtn.removeEventListener('touchstart', handleLeftTouchStart);
            leftBtn.removeEventListener('touchend', handleLeftTouchEnd);
            leftBtn.addEventListener('touchstart', handleLeftTouchStart);
            leftBtn.addEventListener('touchend', handleLeftTouchEnd);
        }
        if (rightBtn) {
            rightBtn.removeEventListener('touchstart', handleRightTouchStart);
            rightBtn.removeEventListener('touchend', handleRightTouchEnd);
            rightBtn.addEventListener('touchstart', handleRightTouchStart);
            rightBtn.addEventListener('touchend', handleRightTouchEnd);
        }
        if (jumpBtn) {
            jumpBtn.removeEventListener('touchstart', handleJumpTouchStart);
            jumpBtn.addEventListener('touchstart', handleJumpTouchStart);
        }
        if (bubbleJumpBtn) {
            bubbleJumpBtn.removeEventListener('touchstart', handleBubbleJumpTouchStart);
            bubbleJumpBtn.addEventListener('touchstart', handleBubbleJumpTouchStart);
        }
        if (shootBtn) {
            shootBtn.removeEventListener('touchstart', handleShootTouchStart);
            shootBtn.addEventListener('touchstart', handleShootTouchStart); 
        }
    }

    function handleLeftTouchStart(e) { e.preventDefault(); if (gameStarted && window.innerWidth > window.innerHeight) baby.dx = -baby.speed; }
    function handleLeftTouchEnd(e) { e.preventDefault(); if (gameStarted) baby.dx = 0; }
    function handleRightTouchStart(e) { e.preventDefault(); if (gameStarted && window.innerWidth > window.innerHeight) baby.dx = baby.speed; }
    function handleRightTouchEnd(e) { e.preventDefault(); if (gameStarted) baby.dx = 0; }
    function handleJumpTouchStart(e) { e.preventDefault(); if (gameStarted && !baby.isJumping && window.innerWidth > window.innerHeight) { baby.dy = baby.jumpPower; baby.isJumping = true; } }
    function handleBubbleJumpTouchStart(e) { e.preventDefault(); if (gameStarted && window.innerWidth > window.innerHeight) bubbleJump(); }
    function handleShootTouchStart(e) { e.preventDefault(); if (gameStarted && window.innerWidth > window.innerHeight) shootPacifier(); } 

    document.addEventListener('keydown', e => {
      if (!gameStarted || window.innerWidth < window.innerHeight) return;
      if (e.key === 'ArrowRight') baby.dx = baby.speed;
      if (e.key === 'ArrowLeft') baby.dx = -baby.speed;
      if ((e.key === 'a' || e.key === 'ㅁ') && !baby.isJumping) {
        baby.dy = baby.jumpPower; baby.isJumping = true;
      }
      if (e.key === ' ') { e.preventDefault(); bubbleJump(); }
      if (e.key === 's' || e.key === 'S' || e.key === 'ㄹ') { 
        e.preventDefault(); 
        shootPacifier();
      }
    });
    document.addEventListener('keyup', e => {
      if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') baby.dx = 0;
    });

    const allGameImages = [
        babyImg, superBabyImg, platformImg, bubbleImg, goalImg, dragonImg, redDragonImg, goldDragonImg, heartImg, diaperImg, 
        pacifierProjectileImg, pacifierItemImg 
    ];
    const imagePromises = allGameImages.map(img => new Promise((resolve, reject) => {
        if (img.complete) resolve();
        else { img.onload = resolve; img.onerror = () => reject(new Error(`Failed to load image: ${img.src}`)); }
    }));
    const audioPromise = new Promise((resolve, reject) => {
        if (bgm) { 
            bgm.oncanplaythrough = resolve; 
            bgm.onerror = (e) => {
                console.error("BGM 로딩 오류:", e);
                reject(new Error("BGM could not be loaded. Check file path and format."));
            };
            setTimeout(() => {
                if (bgm.readyState < 3) {
                    reject(new Error("BGM loading timed out."));
                }
            }, 5000); 
        } else {
            resolve(); 
        }
    });

    document.addEventListener('DOMContentLoaded', () => {
        initializeUIElements(); 
        setupMobileControls();
        
        Promise.all(imagePromises, audioPromise).then(() => { 
            if (startButton) {
                startButton.disabled = false; 
                startButton.textContent = 'Start Game';
            }
            checkOrientation(); 
        }).catch(error => {
            if (startButton) {
                startButton.textContent = '에러! 새로고침 해주세요'; 
                startButton.style.backgroundColor = 'red';
            }
            console.error("Failed to load game assets:", error);
        });
    });

  </script>
</body>
</html>